package planner;

import java.io.*;
import java.util.*;

/**
 * Provides a method to read in a list of venues from a text file.
 */
public class VenueReader {

	/**
	 * <p>
	 * Reads a text file called fileName that describes the venues in a
	 * municipality, and returns a list containing each of the venues read from
	 * the file, in the order that they appear in the file.
	 * </p>
	 * 
	 * <p>
	 * The file contains zero or more descriptions of different venues. (I.e. a
	 * file containing zero venues contains zero lines; a file containing one
	 * venue contains exactly one description of a venue and no other lines or
	 * information; a file containing multiple venues contains each description
	 * of a venue, one after the other with no other information or lines in the
	 * file.)
	 * </p>
	 * 
	 * <p>
	 * A description of a venue consists of exactly (i) one line consisting of
	 * the name of the venue followed by (ii) one line containing a positive
	 * integer denoting the capacity of the venue followed by (iii) a
	 * description of the traffic generated by hosting an event of maximum size
	 * at the venue, followed by (iv) an empty line.
	 * </p>
	 * 
	 * <p>
	 * For (i) the venue name is the entire string on the first line of the
	 * venue description (i.e. it may contain white space characters etc.). The
	 * only constraint on the venue name is that it may not be equal to the
	 * empty string ("").
	 * </p>
	 * 
	 * <p>
	 * For (ii) the second line of a venue description may not contain leading
	 * or trailing whitespace characters, it may only contain a positive integer
	 * denoting the venue capacity.
	 * </p>
	 * 
	 * <p>
	 * For (iii) the traffic is described by one line for each corridor that
	 * will have traffic from the venue when it hosts an event of maximum size.
	 * Each line is a string of the form <br>
	 * <br>
	 * "START, END, CAPACITY: TRAFFIC"<br>
	 * <br>
	 * where START and END are different non-empty strings denoting the name of
	 * the start location of the corridor and the end location of the corridor,
	 * respectively; CAPACITY is a positive integer denoting the capacity of the
	 * corridor; and TRAFFIC is a positive integer denoting the amount of
	 * traffic from the venue that will use the corridor when the venue hosts
	 * the largest event that it can. The strings denoting the start and end
	 * locations of the corridor may contain any characters other than a comma
	 * (',') or semicolon (':'). Both CAPACITY and TRAFFIC should be positive
	 * integers with no additional leading or trailing whitespace. For example,
	 * <br>
	 * <br>
	 * "St. Lucia, Royal Queensland Show - EKKA, 120: 60"<br>
	 * <br>
	 * represents a traffic corridor from "St. Lucia" to "Royal Queensland Show
	 * - EKKA" with a maximum capacity of 120, that will have 60 people from the
	 * venue using it when the venue hosts an event of maximum size. <br>
	 * <br>
	 * Note that the start, end and capacity of a corridor are separated by the
	 * string ", ". The corridor and its traffic are separated by ": ". <br>
	 * <br>
	 * The corridors and their respective traffic may appear in any order (i.e.
	 * the corridors aren't necessarily sorted in any way.) Each corridor may
	 * only appear once in the traffic description for a venue (i.e. there is
	 * only one line for each corridor), and the traffic on that corridor should
	 * be less than or equal to the capacity of the venue, and less than or
	 * equal to the capacity of the corridor.
	 * </p>
	 * 
	 * <p>
	 * For (iv) an empty line is a line with no characters at all (i.e. the
	 * contents of the line is the empty string "").
	 * </p>
	 * 
	 * <p>
	 * Two equivalent venues shouldn't appear twice in the file.
	 * </p>
	 * 
	 * <p>
	 * If a FormatException is thrown, it will have a meaningful message that
	 * accurately describes the problem with the input file format, including
	 * the line of the file where the problem was detected.
	 * </p>
	 * 
	 * @param fileName
	 *            the name of the file to read from.
	 * @return a list of the venues from the file, in the order in which they
	 *         appear in the file.
	 * @throws IOException
	 *             if there is an error reading from the input file.
	 * @throws FormatException
	 *             if there is an error with the input format (e.g. there is
	 *             more than one venue description in the file that describes
	 *             the same venue, or the file format is not as specified above
	 *             in any other way.) The FormatExceptions thrown should have a
	 *             meaningful message that accurately describes the problem with
	 *             the input file format, including the line of the file where
	 *             the problem was detected.
	 */
	public static List<Venue> read(String fileName) throws IOException,
	FormatException {
		List<Venue> venueList = new ArrayList<Venue>();
		BufferedReader reader = new BufferedReader(new FileReader(new File(fileName))); 

		String line = "";
		int lineCount = 0;
		while((line = reader.readLine()) != null) {
			lineCount++;
			if(line.length() == 0) continue;

			String venueName = line;
			int capacity;
			try {
				lineCount++;
				capacity = Integer.valueOf(reader.readLine().trim());
			} catch(NumberFormatException e) {
				throw new FormatException("Capacity of the venue "+venueName+" is not properly formatted in line#"+lineCount);
			}


			String corridor = reader.readLine().trim();
			lineCount++;
			Traffic traffic = new Traffic();
			ArrayList<Corridor> corridors = new ArrayList<Corridor>();
			while(corridor.length()!=0) {
				try {

					String parts[] = corridor.split(": ");
					String[] info = parts[0].split(", ");
					Location start = new Location(info[0]);
					Location end = new Location(info[1]);
					int capacityCorridor = Integer.valueOf(info[2]);
					int trafficCount = Integer.valueOf(parts[1]);
					if(trafficCount > capacity || trafficCount > capacityCorridor) {
						throw new FormatException("Corridor traffic is greater than the corridor/venue capacity in line#"+lineCount);
					}
					if(end.getName().length() == 0  || start.getName().length() == 0 ) {
						throw new FormatException("Start/END name of Corridor is empty/wrong in line#"+lineCount);
					}

					Corridor c = new Corridor(start, end, capacityCorridor);
					if(corridors.contains(c)) {
						throw new FormatException("Same Corridor name mentioned more than once for one venue in line#"+lineCount);
					} else {
						corridors.add(c);
					}

					traffic.updateTraffic(c, trafficCount);

					corridor = reader.readLine().trim();
					lineCount++;

				}catch(FormatException e){
					throw e;
				}catch(Exception e) {


					throw new FormatException("Corridor description has wrong formate in line#"+lineCount);
				}

			}
			Venue venue = new Venue(venueName, capacity, traffic);
			if (!venueList.contains(venue)) {
				venueList.add(venue);
			} else {
				throw new FormatException("Venue :"+venueName+" mentioned more than once line#"+lineCount);
			}

		}


		return venueList; 
	}

}
